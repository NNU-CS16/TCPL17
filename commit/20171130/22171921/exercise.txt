1. 1；
优先级： 算数>条件>关系>赋值
关系中的优先级： 非>与>或
a+b=5!=0所以为真,所以!(a+b)=0;然后再算除号的,c、b都是整形的，所以小数点后面的数忽略，所以就变成0-c+1&&c+1；接着计算加减运算，也就是变成-3&&5两真为真所以最后结果为1；

2. c=0; d=1;
a&b即将a,b转化为二进制相与，结果为0，所以为假，故整体为假所以c的值为0；
a&&b即a,b均为真，所以整体为真，所以为1；1&a即1&1是1与上1，结果为1；

3. D；
*p保存的是内容，也就是*p=1009;D选项，*p++，实际上就是*(p++)，也就是p指针后移了一位，但是year的内容并没有改变，因为p只是指向year这块内存的指针。

4. 9；
因为x=2,所以f(2)=3;因为3>2所以f(3)=3*f(3-1=2)=9;

5. C;
选项C错误是因为函数行参类型不匹配。函数名在使用上是和指针等同，但其并非是一个真正的指针。C里面函数名等价于函数名取地址,所以ABD中不管有没有取地址符号，表达的意思都一样,C错误在于函数指针pf指向的函数的参数类型与 f2函数的参数类型不一样。

6. Beijing;
在内存中的存储方式
C h i n a \0 \0 \0 \0 \0   ——A行
B e i j i  n  g \0 \0 \0   ——B行
每行10个储存地址。*p=str就是把字符串的首地址(也就是China)赋给指针p。然后p+10就是把指针指向向下移动10个存储地址。就是指到了B行;所以printf结果是 Beijing;

7. D;
按值传递，函数返回后，局部变量的值不会随着调用函数内部的实现改变而改变。按地址传递和按指针传递，才会改变局部变量的值。这道题，GetMemory（）是按照按值传递的，因而局部变量，不会因为函数内部 p = (char*)malloc(100);的实现，而更改。返回主函数后， 仍然是 *str = NULL;。因而在改指针执行操作，会造成程序崩溃。因为没有为它分配内存。

8. B;
首先，a是指针，不是数组，然后a是数组指针，不仅仅是指针。所以A，C排除了。那么剩下两项B，D.char (*a) [10] ; char *a [10] ;这里就是一个优先级的问题了，[]优先级要高于解引用运算符。所以第一个a为指针，指向具有十个char元素的指针。第二个为数组，每个元素都是指针，每个指针指向一个char变量。

9. 14;
函数的作用是统计x二进制数中1的个数。这个作用是对整型中1的个数进行统计，x=x&(x-1);的作用是每次循环把x的二进制中从右往左数的最后一位1变成0，直道变成全0为止，循环结束。
65530的二进制是0000 0000 0000 0000 1111 1111 1111 1010，所以结果是14

10. AB;
(1)数组A的下标范围为：0….MAX-1； 
(2)当i循环到255时，循环内执行： A[255]=255；这句本身没有问题，但是返回for (i=0;i<=MAX;i++)语句时，由于unsigned char的取值范围在(0..255)，i++以后i又为0了，这样就会无限循环下去，造成了死循环； 
