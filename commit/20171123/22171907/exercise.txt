1、a=1  b=0  c=1  d=2
  析：对于b来说,只有int b=0的操作,所以很简单b=0;
      对于a来说,在int d=(++a)*(c=1);语句中经历了++a所以a=1+1=2;
      对于c来说,经历了c=1的赋值，所以c=1;
      最终d=2×1=2.

2.15
  析：程序是按照步骤来的。对于a++，在那一行代码中，a的值是不变的下一行才发生改变,对于b++，b的值已经改变了，所以执行的是3×5,所以=15。

3.j<i
  析：当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C 语言会隐式地将有符号参数强制类型为无符号数，并假设这两个数都是非负的，来执行这个运算。在32和64位的机子上-1对应的无符号数应该是4294967295,
  即i=4294967295,j=1,所以j<i

4.2 5
析：a既是数据名，又是指向数组的第一个元素的指针。*(a+1)中把a当成一个指针，
a+1=a+sizeof(int),a+1指向a的下一个整形地址既&a[1].所以*(a+1)=*(&a[1])=a[1]=2(&a+1)先取变量的地址，并根据的地址获得下一个与同类型的相邻地址。
(&a+1)=&a+sizeof(5*int),所以&a+1指向的地址&a[5](数组a[5]的下一个地址)
所以ptr指向&a[5],ptr-1=ptr-sizeof(int),所以(ptr-1)指向的值为&a[4],
*(ptr-1)=a[4]=5

5.10,20,30
析:(*p)[3]是行指针变量，p=arr对行指针变量进行了初始化,通过行指针变量引用二维数组的元素，所以p[0][0]=10,*(p[0]+1)=p[0][1]=20,(*p)[2]=p[0][2]=30.

6.0
析：char str[]="ABCD"相当于char str[5]={'A','B','C','D',0}*(p+4)相当于str[4]的值是0

7.2
析：m=a>b,5>7结果为0,由于是与运算，后面的式子就不用执行了，n前后的值没有改变

8.10.4
sizeof返回数组所占的字节数，'wang''miao'共占8字节，显示'\0'占1字节，字符串末尾隐式'\0'占1字节,共10字节
strlen返回字符串长度一遇到'\0'结束符为准，因此为4.

9.0x80105 0x801014(0x801028)
析：p1是字符指针，一个字符一个字节，指针移动一个元素移动一个字节，+5之后就是0x801005
p2是long型指针，long四个字节，移动五次，移动20个字节，十六进制形式是0x810014
标准C规定至少是32位，随编译器不同，在VC6中就是64位，所以在编程序验证时在手机上和在电脑上我得到两个不同的答案。

10.7
析：static变量是静态变量。第二次调用时就还保留着上次函数执行完时的数值，第三次调用的情形和第二次调用的情形相同.n=1+1=2,i=2,return func(2);n=2+2,i=3,return func(4);n=4+3=7>5,so func(1)=7.
~
